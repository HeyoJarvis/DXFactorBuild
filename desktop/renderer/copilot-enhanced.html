<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="Content-Security-Policy" content="default-src 'self' 'unsafe-inline' data: https: http://localhost:*; script-src 'self' 'unsafe-inline'; style-src 'self' 'unsafe-inline' https://fonts.googleapis.com; font-src 'self' https://fonts.gstatic.com; connect-src 'self' http://localhost:* https:;">
  <title>HeyJarvis Copilot Enhanced</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=SF+Pro+Display:wght@300;400;500;600;700&family=SF+Pro+Text:wght@300;400;500;600&display=swap');
    
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'SF Pro Text', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: rgba(28, 28, 30, 0.95); /* Apple's dark mode background */
      color: #ffffff;
      height: 100vh;
      width: 100vw;
      margin: 0;
      padding: 0;
      display: flex;
      flex-direction: column;
      overflow: hidden;
      backdrop-filter: blur(20px) saturate(180%);
      transition: all 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94);
      position: relative;
      border-radius: 16px; /* More Apple-like radius */
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4), 0 0 0 0.5px rgba(255, 255, 255, 0.1);
      border: 0.5px solid rgba(255, 255, 255, 0.08);
    }

    /* Top bar collapsed state */
    body.collapsed {
      height: 60px; /* Apple-like height */
      background: rgba(28, 28, 30, 0.85);
      backdrop-filter: blur(20px) saturate(180%);
    }

    /* Top bar expanded state */
    body.expanded {
      height: 680px;
      background: rgba(28, 28, 30, 0.95);
      box-shadow: 0 16px 64px rgba(0, 0, 0, 0.5), 0 0 0 0.5px rgba(255, 255, 255, 0.1);
      backdrop-filter: blur(40px) saturate(200%);
    }

    /* Subtle Apple-inspired ambient glow */
    body::before {
      content: '';
      position: absolute;
      top: -20%;
      left: -20%;
      width: 140%;
      height: 140%;
      background: radial-gradient(circle at center, 
        rgba(0, 122, 255, 0.02) 0%, 
        rgba(88, 86, 214, 0.01) 40%, 
        transparent 70%);
      animation: breathe 6s ease-in-out infinite;
      pointer-events: none;
      z-index: -1;
    }

    /* Collapsed state - show header chat, hide main content and bottom input */
    body.collapsed .copilot-content {
      display: none !important;
    }

    body.collapsed .header-chat-container {
      display: flex !important;
    }

    /* Expanded state - hide header chat, show main content and bottom input */
    body.expanded .copilot-content {
      display: flex !important;
    }

    body.expanded .header-chat-container {
      display: none !important;
    }

    /* Content area styling */
    .copilot-content {
      flex: 1;
      display: none; /* Hidden by default, shown when expanded */
      flex-direction: column;
      overflow: hidden;
      min-height: 0; /* Important for flex children */
    }

    @keyframes breathe {
      0%, 100% { opacity: 0.2; transform: scale(1); }
      50% { opacity: 0.4; transform: scale(1.02); }
    }

    /* Top Bar Header */
    .copilot-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 16px 32px;
      height: 60px;
      background: transparent;
      transition: all 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94);
      border-radius: 16px;
      gap: 20px;
      position: relative;
      flex-shrink: 0; /* Prevent header from shrinking */
    }

    /* Header Chat Container - Only visible when collapsed */
    .header-chat-container {
      display: flex;
      align-items: center;
      flex: 1;
      max-width: 300px;
      gap: 8px;
      -webkit-app-region: no-drag; /* Prevent dragging on chat area */
    }

    .header-chat-input {
      flex: 1;
      background: rgba(255, 255, 255, 0.08);
      border: 1px solid rgba(255, 255, 255, 0.12);
      border-radius: 22px;
      padding: 10px 18px;
      color: #ffffff;
      font-size: 14px;
      font-family: 'SF Pro Text', -apple-system, BlinkMacSystemFont, sans-serif;
      outline: none;
      transition: all 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94);
      min-width: 0;
      -webkit-app-region: no-drag;
      backdrop-filter: blur(10px);
    }

    .header-chat-input::placeholder {
      color: rgba(255, 255, 255, 0.5);
    }

    .header-chat-input:focus {
      background: rgba(255, 255, 255, 0.12);
      border-color: rgba(0, 122, 255, 0.6);
      box-shadow: 0 0 0 3px rgba(0, 122, 255, 0.15);
      transform: scale(1.02);
    }

    .header-send-btn {
      width: 36px;
      height: 36px;
      border: none;
      border-radius: 50%;
      background: linear-gradient(135deg, #007AFF 0%, #5856D6 100%);
      color: #ffffff;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 16px;
      font-weight: 600;
      transition: all 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94);
      -webkit-app-region: no-drag;
      box-shadow: 0 2px 8px rgba(0, 122, 255, 0.3);
    }

    .header-send-btn:hover {
      transform: scale(1.08);
      box-shadow: 0 4px 16px rgba(0, 122, 255, 0.4);
    }

    .header-send-btn:active {
      transform: scale(0.95);
    }

    /* Dragging state */
    body.dragging {
      cursor: move !important;
      box-shadow: 0 8px 25px rgba(0, 212, 255, 0.3) !important;
    }

    body.dragging .copilot-header {
      background: rgba(0, 212, 255, 0.1) !important;
    }

    /* Manual positioning indicator */
    .position-indicator {
      position: absolute;
      top: 2px;
      right: 2px;
      width: 6px;
      height: 6px;
      background: rgba(0, 212, 255, 0.6);
      border-radius: 50%;
      opacity: 0;
      transition: opacity 0.3s ease;
    }

    body.manually-positioned .position-indicator {
      opacity: 1;
    }

    /* Hide header content when collapsed except for the main title */
    body.collapsed .copilot-header .copilot-controls {
      display: none;
    }

    body.collapsed .copilot-title {
      font-size: 15px; /* Slightly larger for taller bar */
      font-weight: 500;
    }

    .copilot-title {
      display: flex;
      align-items: center;
      gap: 14px;
      font-family: 'SF Pro Display', -apple-system, BlinkMacSystemFont, sans-serif;
      font-weight: 600;
      font-size: 17px;
      color: #ffffff;
      cursor: move;
      padding: 10px 16px;
      border-radius: 12px;
      transition: all 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94);
      user-select: none;
      -webkit-app-region: drag;
      letter-spacing: -0.02em;
    }

    .copilot-title:hover {
      background: rgba(255, 255, 255, 0.08);
    }

    .copilot-icon {
      width: 36px;
      height: 36px;
      border-radius: 50%;
      filter: drop-shadow(0 2px 8px rgba(0, 0, 0, 0.3));
      transition: all 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94);
    }

    .copilot-icon:hover {
      filter: drop-shadow(0 0 10px rgba(0, 212, 255, 0.6));
      transform: scale(1.05);
    }

    .copilot-controls {
      display: flex;
      gap: 8px;
      -webkit-app-region: no-drag; /* Prevent dragging on controls */
    }

    .control-btn {
      width: 28px;
      height: 28px;
      border: none;
      border-radius: 50%;
      background: rgba(255, 255, 255, 0.06);
      color: rgba(255, 255, 255, 0.6);
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 14px;
      font-weight: 500;
      transition: all 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94);
      -webkit-app-region: no-drag;
      backdrop-filter: blur(10px);
    }

    .control-btn:hover {
      background: rgba(255, 255, 255, 0.15);
      transform: scale(1.1);
      color: rgba(255, 255, 255, 0.9);
    }

    .control-btn.close:hover {
      background: rgba(255, 69, 58, 0.8);
      color: #ffffff;
    }

    /* Status Bar */
    .status-bar {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px 24px;
      background: rgba(0, 0, 0, 0.1);
      border-bottom: 1px solid rgba(255, 255, 255, 0.06);
      backdrop-filter: blur(10px);
      flex-shrink: 0; /* Prevent status bar from shrinking */
    }

    .status-indicators {
      display: flex;
      gap: 20px;
    }

    .status-item {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 13px;
      font-weight: 500;
    }

    .status-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: rgba(142, 142, 147, 0.8);
      transition: all 0.3s ease;
    }

    .status-dot.online {
      background: #34C759;
      box-shadow: 0 0 8px rgba(52, 199, 89, 0.4);
    }

    .status-dot.loading {
      background: #FF9F0A;
      animation: pulse-status 2s ease-in-out infinite;
    }

    .status-label {
      color: rgba(255, 255, 255, 0.7);
      font-size: 12px;
    }

    .activity-summary {
      font-size: 12px;
      color: rgba(255, 255, 255, 0.6);
    }

    @keyframes pulse-status {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }

    /* Chat Interface - Main container */
    .chat-interface {
      flex: 1;
      display: flex;
      flex-direction: column;
      overflow: hidden;
      min-height: 0; /* Important for flex children */
    }
    
    /* Ensure input container is always visible */
    body.expanded .input-container {
      display: block !important;
      position: relative;
      z-index: 100;
    }

    /* Enhanced Chat Styles */
    .chat-container {
      flex: 1;
      overflow-y: auto;
      padding: 24px;
      display: flex;
      flex-direction: column;
      gap: 20px;
      scroll-behavior: smooth;
      min-height: 0; /* Allow shrinking */
      max-height: calc(100% - 180px); /* Leave space for input container */
    }

    .welcome-message {
      text-align: center;
      padding: 32px 24px;
      background: rgba(0, 122, 255, 0.04);
      border-radius: 20px;
      border: 1px solid rgba(255, 255, 255, 0.08);
      backdrop-filter: blur(20px);
    }

    .welcome-icon {
      font-size: 40px;
      margin-bottom: 16px;
      filter: drop-shadow(0 2px 8px rgba(0, 122, 255, 0.3));
    }

    .welcome-text {
      font-family: 'SF Pro Display', -apple-system, BlinkMacSystemFont, sans-serif;
      font-size: 22px;
      font-weight: 600;
      margin-bottom: 12px;
      letter-spacing: -0.02em;
    }

    .welcome-subtitle {
      font-size: 15px;
      color: rgba(255, 255, 255, 0.7);
      margin-bottom: 28px;
      line-height: 1.4;
    }

    .quick-actions {
      display: grid;
      grid-template-columns: 1fr;
      gap: 12px;
      max-width: 400px;
      margin: 0 auto;
    }

    .quick-action {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 16px 20px;
      background: rgba(255, 255, 255, 0.06);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 16px;
      cursor: pointer;
      font-size: 14px;
      font-weight: 500;
      transition: all 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94);
      text-align: left;
      backdrop-filter: blur(10px);
    }

    .quick-action:hover {
      background: rgba(255, 255, 255, 0.12);
      border-color: rgba(0, 122, 255, 0.3);
      transform: translateY(-2px) scale(1.02);
      box-shadow: 0 8px 25px rgba(0, 0, 0, 0.15);
    }

    .action-icon {
      font-size: 18px;
      opacity: 0.8;
    }

    .action-text {
      flex: 1;
      font-weight: 500;
    }

    /* Enhanced Typing Indicator */
    .typing-indicator {
      display: none;
      padding: 20px 24px;
      align-items: center;
      gap: 16px;
      background: rgba(0, 122, 255, 0.04);
      border-top: 1px solid rgba(255, 255, 255, 0.06);
      font-size: 14px;
      color: rgba(255, 255, 255, 0.8);
      backdrop-filter: blur(10px);
      flex-shrink: 0; /* Prevent typing indicator from shrinking */
    }

    .typing-avatar {
      font-size: 20px;
      opacity: 0.8;
    }

    .typing-content {
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .typing-text {
      font-weight: 500;
    }

    .typing-dots {
      display: flex;
      gap: 6px;
    }

    .typing-dot {
      width: 8px;
      height: 8px;
      background: #007AFF;
      border-radius: 50%;
      animation: typing 1.6s infinite ease-in-out;
    }

    .typing-dot:nth-child(1) { animation-delay: -0.32s; }
    .typing-dot:nth-child(2) { animation-delay: -0.16s; }

    @keyframes typing {
      0%, 80%, 100% { transform: scale(0.9); opacity: 0.4; }
      40% { transform: scale(1.1); opacity: 1; }
    }

    /* Message Styles */
    .message {
      display: flex;
      gap: 12px;
      margin-bottom: 16px;
      animation: slideIn 0.3s ease-out;
    }

    @keyframes slideIn {
      from { opacity: 0; transform: translateY(10px); }
      to { opacity: 1; transform: translateY(0); }
    }

    .message.user {
      flex-direction: row-reverse;
    }

    .message-avatar {
      width: 32px;
      height: 32px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 14px;
      flex-shrink: 0;
    }

    .message.user .message-avatar {
      background: linear-gradient(135deg, #00d4ff, #0099cc);
    }

    .message.assistant .message-avatar {
      background: rgba(0, 212, 255, 0.1);
      border: 1px solid rgba(0, 212, 255, 0.3);
    }

    .message-content {
      flex: 1;
      background: rgba(0, 0, 0, 0.2);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 12px;
      padding: 12px 16px;
      font-size: 14px;
      line-height: 1.5;
      max-width: 80%;
    }

    .message.user .message-content {
      background: linear-gradient(135deg, rgba(0, 212, 255, 0.2), rgba(0, 153, 204, 0.1));
      border-color: rgba(0, 212, 255, 0.3);
    }

    .message-time {
      font-size: 11px;
      color: rgba(255, 255, 255, 0.4);
      margin-top: 4px;
    }

    .message-input {
      flex: 1;
      background: rgba(255, 255, 255, 0.08);
      border: 1px solid rgba(255, 255, 255, 0.12);
      border-radius: 20px;
      padding: 16px 20px;
      color: #ffffff;
      font-size: 15px;
      font-family: 'SF Pro Text', -apple-system, BlinkMacSystemFont, sans-serif;
      resize: none;
      min-height: 50px;
      max-height: 140px;
      transition: all 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94);
      backdrop-filter: blur(10px);
    }

    .message-input:focus {
      outline: none;
      background: rgba(255, 255, 255, 0.12);
      border-color: rgba(0, 122, 255, 0.6);
      box-shadow: 0 0 0 3px rgba(0, 122, 255, 0.15);
      transform: scale(1.01);
    }

    .message-input::placeholder {
      color: rgba(255, 255, 255, 0.4);
    }

    /* Bottom Input Container - Fixed positioning */
    .input-container {
      padding: 20px 24px;
      background: rgba(0, 0, 0, 0.3); /* More visible background */
      border-top: 1px solid rgba(255, 255, 255, 0.2);
      backdrop-filter: blur(20px);
      flex-shrink: 0; /* Prevent input from shrinking */
      min-height: 80px; /* Ensure minimum height */
    }

    .input-wrapper {
      display: flex;
      gap: 16px;
      align-items: flex-end;
      max-width: 800px;
      margin: 0 auto;
    }

    .send-btn {
      width: 50px;
      height: 50px;
      background: linear-gradient(135deg, #007AFF 0%, #5856D6 100%);
      border: none;
      border-radius: 50%;
      color: #ffffff;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94);
      box-shadow: 0 4px 16px rgba(0, 122, 255, 0.3);
      flex-shrink: 0; /* Prevent button from shrinking */
    }

    .send-btn:hover {
      transform: translateY(-2px) scale(1.05);
      box-shadow: 0 8px 25px rgba(0, 122, 255, 0.4);
    }

    .send-btn:active {
      transform: translateY(0);
    }

    /* Minimized state */
    body.minimized {
      width: 60px !important;
      height: 60px !important;
      border-radius: 50% !important;
      background: radial-gradient(circle at center, 
        rgba(0, 212, 255, 0.8) 0%, 
        rgba(0, 150, 200, 0.6) 50%, 
        rgba(0, 100, 150, 0.8) 100%) !important;
      box-shadow: 
        0 0 30px rgba(0, 212, 255, 0.8),
        0 0 60px rgba(0, 212, 255, 0.4),
        inset 0 0 20px rgba(255, 255, 255, 0.2) !important;
    }

    body.minimized .copilot-header,
    body.minimized .tab-navigation,
    body.minimized .copilot-content {
      display: none !important;
    }

    /* Loading states */
    .loading {
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 20px;
      color: rgba(255, 255, 255, 0.6);
      font-size: 13px;
    }

    /* Scrollbar */
    ::-webkit-scrollbar {
      width: 6px;
    }

    ::-webkit-scrollbar-track {
      background: rgba(0, 0, 0, 0.1);
    }

    ::-webkit-scrollbar-thumb {
      background: rgba(0, 212, 255, 0.3);
      border-radius: 3px;
    }

    ::-webkit-scrollbar-thumb:hover {
      background: rgba(0, 212, 255, 0.5);
    }
  </style>
</head>
<body>
  <div class="copilot-header">
    <div class="copilot-title" id="dragHandle">
      <img src="/Users/jarvis/Code/HeyJarvis/Jarvis.png" alt="Jarvis" class="copilot-icon">
      HeyJarvis
    </div>
    
    <!-- Header Chat Container - Only visible when collapsed -->
    <div class="header-chat-container">
      <input type="text" 
             class="header-chat-input" 
             id="headerChatInput"
             placeholder="Ask me anything..." 
             autocomplete="off"
             spellcheck="false">
      <button class="header-send-btn" id="headerSendBtn" onclick="sendHeaderMessage()">
        <span>‚Üí</span>
      </button>
    </div>
    
    <div class="copilot-controls">
      <button class="control-btn minimize" onclick="collapseTopBar()" title="Collapse to header chat">‚àí</button>
      <button class="control-btn close" onclick="closeWindow()" title="Hide">√ó</button>
    </div>
  </div>
  
  <!-- Position indicator -->
  <div class="position-indicator" title="Manually positioned - double-click to reset"></div>

  <div class="copilot-content">
    <!-- Status Bar -->
    <div class="status-bar" id="statusBar">
      <div class="status-indicators">
        <div class="status-item" id="slackStatus">
          <div class="status-dot" id="slackStatusDot"></div>
          <span class="status-label">Slack</span>
        </div>
        <div class="status-item" id="crmStatus">
          <div class="status-dot" id="crmStatusDot"></div>
          <span class="status-label">CRM</span>
        </div>
      </div>
      <div class="activity-summary" id="activitySummary">
        <span class="activity-text">All systems ready</span>
      </div>
  </div>

    <!-- Chat Interface -->
    <div class="chat-interface">
      <div class="chat-container" id="chatContainer">
        <div class="welcome-message">
          <div class="welcome-icon">‚ú®</div>
          <div class="welcome-text">Hello! I'm your AI copilot.</div>
          <div class="welcome-subtitle">I can help with competitive intelligence, CRM insights, and Slack monitoring.</div>
          
          <div class="quick-actions">
            <div class="quick-action" onclick="sendQuickMessage('What are the latest competitor moves?')">
              <div class="action-icon">üìä</div>
              <div class="action-text">Latest competitor moves</div>
            </div>
            <div class="quick-action" onclick="sendQuickMessage('Analyze my CRM data')">
              <div class="action-icon">üß†</div>
              <div class="action-text">CRM insights</div>
            </div>
            <div class="quick-action" onclick="sendQuickMessage('Show Slack activity')">
              <div class="action-icon">üí¨</div>
              <div class="action-text">Slack activity</div>
            </div>
            <div class="quick-action" onclick="startFactCheck()">
              <div class="action-icon">üîç</div>
              <div class="action-text">Fact Check Screen</div>
          </div>
            <div class="quick-action" onclick="testHighlights()">
              <div class="action-icon">üß™</div>
              <div class="action-text">Test Highlights</div>
            </div>
            <div class="quick-action" onclick="findHeyjarvisText()">
              <div class="action-icon">üîç</div>
              <div class="action-text">Find "HeyJarvis" Text</div>
            </div>
            <div class="quick-action" onclick="calibrateHighlights()">
              <div class="action-icon">üéØ</div>
              <div class="action-text">Calibrate Positioning</div>
            </div>
            <div class="quick-action" onclick="testSimpleHighlights()">
              <div class="action-icon">üî¥</div>
              <div class="action-text">Simple Test Highlights</div>
            </div>
          </div>
        </div>
      </div>

      <div class="typing-indicator" id="typingIndicator">
        <div class="typing-avatar">‚ú®</div>
        <div class="typing-content">
          <span class="typing-text">HeyJarvis is thinking</span>
        <div class="typing-dots">
          <div class="typing-dot"></div>
          <div class="typing-dot"></div>
          <div class="typing-dot"></div>
          </div>
        </div>
      </div>

      <!-- Bottom Input Container - Now properly positioned -->
      <div class="input-container">
        <div class="input-wrapper">
          <textarea 
            class="message-input" 
            id="messageInput" 
            placeholder="Ask me anything about your business..."
            rows="1"
          ></textarea>
          <button class="send-btn" id="sendBtn" onclick="sendMessage()">
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <path d="m22 2-7 20-4-9-9-4z"/>
              <path d="M22 2 11 13"/>
            </svg>
          </button>
        </div>
      </div>
    </div>
  </div>

  <script>
    let isMinimized = false;
    let chatHistory = [];
    let crmData = null;
    let crmUpdateInterval = null;
    let slackConnected = false;
    let slackMessages = [];
    let slackUpdateInterval = null;
    let servicesInitialized = false;

    // DOM elements
    const chatContainer = document.getElementById('chatContainer');
    const messageInput = document.getElementById('messageInput');
    const headerChatInput = document.getElementById('headerChatInput');
    const sendBtn = document.getElementById('sendBtn');
    const headerSendBtn = document.getElementById('headerSendBtn');
    const typingIndicator = document.getElementById('typingIndicator');

    // Auto-initialize services on app launch
    async function initializeServices() {
      if (servicesInitialized) return;
      
      console.log('üöÄ Auto-initializing services...');
      servicesInitialized = true;
      
      // Update status indicators
      updateStatusIndicator('slack', 'loading', 'Connecting...');
      updateStatusIndicator('crm', 'loading', 'Loading...');
      
      // Auto-start Slack monitoring
      try {
        const slackResult = await window.electronAPI.slack.startMonitoring();
        if (slackResult.success) {
          console.log('‚úÖ Slack auto-initialized');
          updateStatusIndicator('slack', 'online', 'Connected');
          startSlackUpdates();
      } else {
          console.log('‚ö†Ô∏è Slack initialization failed:', slackResult.error);
          updateStatusIndicator('slack', 'offline', 'Failed');
        }
      } catch (error) {
        console.log('‚ùå Slack auto-init error:', error);
        updateStatusIndicator('slack', 'offline', 'Error');
      }
      
      // Auto-load CRM data
      try {
        await loadCRMData();
        console.log('‚úÖ CRM auto-initialized');
        updateStatusIndicator('crm', 'online', 'Ready');
        startCRMUpdates();
      } catch (error) {
        console.log('‚ùå CRM auto-init error:', error);
        updateStatusIndicator('crm', 'offline', 'Error');
      }
      
      // Update activity summary
      updateActivitySummary();
    }
    
    function updateStatusIndicator(service, status, message) {
      const statusDot = document.getElementById(`${service}StatusDot`);
      if (statusDot) {
        statusDot.className = `status-dot ${status}`;
      }
    }
    
    function updateActivitySummary() {
      const summaryEl = document.getElementById('activitySummary');
      if (!summaryEl) return;
      
      let summary = 'All systems ready';
      if (!slackConnected && !crmData?.connected) {
        summary = 'Services initializing...';
      } else if (!slackConnected) {
        summary = 'CRM ready ‚Ä¢ Slack offline';
      } else if (!crmData?.connected) {
        summary = 'Slack ready ‚Ä¢ CRM loading';
      }
      
      summaryEl.textContent = summary;
    }

    // CRM AI Insights Management
    async function loadCRMData() {
      try {
        if (!window.electronAPI) {
          throw new Error('Electron API not available');
        }
        
        // Get CRM data from the startup service via Electron API
        const response = await window.electronAPI.getCRMData();
        
        if (response.isLoading) {
          // Show loading progress if still loading
          return;
        }
        
        if (!response.success) {
          throw new Error(response.error || 'Failed to load CRM data');
      }

      // Store data for future use
        crmData = response.data;
        
      } catch (error) {
        console.error('‚ùå Failed to load CRM data:', error);
      }
    }

    function startCRMUpdates() {
      // Update CRM data every 2 minutes
      crmUpdateInterval = setInterval(loadCRMData, 120000);
    }

    function stopCRMUpdates() {
      if (crmUpdateInterval) {
        clearInterval(crmUpdateInterval);
        crmUpdateInterval = null;
      }
    }

    // Slack Functions (now auto-initialized)
    async function toggleSlackMonitoring() {
      // This function is kept for compatibility but Slack auto-starts now
      try {
        if (slackConnected) {
          const result = await window.electronAPI.slack.stopMonitoring();
          if (result.success) {
            slackConnected = false;
            updateStatusIndicator('slack', 'offline', 'Disconnected');
            stopSlackUpdates();
            updateActivitySummary();
          }
        } else {
          const result = await window.electronAPI.slack.startMonitoring();
          if (result.success) {
            slackConnected = true;
            updateStatusIndicator('slack', 'online', 'Connected');
            startSlackUpdates();
            loadSlackMessages();
            updateActivitySummary();
          }
        }
      } catch (error) {
        console.error('Error toggling Slack monitoring:', error);
        updateStatusIndicator('slack', 'offline', 'Error');
      }
    }

    async function loadSlackMessages() {
      try {
        const messages = await window.electronAPI.slack.getRecentMessages(20);
        const status = await window.electronAPI.slack.getStatus();
        
        slackMessages = messages;
      } catch (error) {
        console.error('Error loading Slack messages:', error);
      }
    }

    function startSlackUpdates() {
      // Update Slack messages every 10 seconds
      slackUpdateInterval = setInterval(loadSlackMessages, 10000);
    }

    function stopSlackUpdates() {
      if (slackUpdateInterval) {
        clearInterval(slackUpdateInterval);
        slackUpdateInterval = null;
      }
    }

    function onSlackMention(message) {
      console.log('üîî New Slack mention:', message);
      slackMessages.unshift(message);
      
      // Keep only last 50 messages
      if (slackMessages.length > 50) {
        slackMessages = slackMessages.slice(0, 50);
      }
      
      // Update UI
        loadSlackMessages();
    }

    function onSlackMessage(message) {
      console.log('üí¨ New Slack message:', message);
      slackMessages.unshift(message);
      
      if (slackMessages.length > 50) {
        slackMessages = slackMessages.slice(0, 50);
      }
      
        loadSlackMessages();
    }

    // Auto-resize textarea (for bottom input)
    if (messageInput) {
    messageInput.addEventListener('input', function() {
      this.style.height = 'auto';
      this.style.height = Math.min(this.scrollHeight, 120) + 'px';
    });

    // Send message on Enter (but not Shift+Enter)
    messageInput.addEventListener('keydown', function(e) {
      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        sendMessage();
      }
    });
    }

    // Header chat input event listeners
    if (headerChatInput) {
      headerChatInput.addEventListener('keydown', function(e) {
        if (e.key === 'Enter') {
          e.preventDefault();
          sendHeaderMessage();
        }
      });

      // Auto-expand when user starts typing in header
      headerChatInput.addEventListener('focus', () => {
        if (!isExpanded) {
          console.log('üîç Auto-expanding due to header chat input focus');
          expandTopBar();
        }
      });
    }

    // Window controls
    function minimizeWindow(event) {
      if (event) {
        event.stopPropagation();
        event.preventDefault();
      }
      
      console.log('üì¶ Collapsing top bar...');
      collapseTopBar();
    }

    function closeWindow() {
      console.log('üîÑ Closing copilot window...');
      stopCRMUpdates();
      if (window.electronAPI) {
        window.electronAPI.closeWindow();
      } else {
        window.close();
      }
    }

    // Chat functionality - works for both header and bottom inputs
    async function sendMessage() {
      const message = messageInput.value.trim();
      if (!message) return;

      await processChatMessage(message);
      messageInput.value = '';
      messageInput.style.height = 'auto';
    }

    async function sendHeaderMessage() {
      const message = headerChatInput.value.trim();
      if (!message) return;

      // Expand to show full chat interface
      if (!isExpanded) {
        expandTopBar();
      }

      await processChatMessage(message);
      headerChatInput.value = '';
    }

    async function processChatMessage(message) {
      // Add user message to chat
      addMessage(message, 'user');

      // Show typing indicator
      showTypingIndicator();

      try {
        // Send to backend
        let response;
        if (window.electronAPI) {
          response = await window.electronAPI.sendMessage(message);
        } else {
          // Fallback for testing
          response = {
            type: 'message',
            content: 'I\'m here to help with competitive intelligence insights. What would you like to know?',
            timestamp: new Date().toISOString()
          };
        }

        // Add assistant response
        hideTypingIndicator();
        addMessage(response.content, 'assistant');

      } catch (error) {
        console.error('Error sending message:', error);
        hideTypingIndicator();
        addMessage('Sorry, I encountered an error. Please try again.', 'assistant');
      }
    }

    function sendQuickMessage(message) {
      // Use the appropriate input based on current state
      if (isExpanded && messageInput) {
      messageInput.value = message;
      sendMessage();
      } else if (headerChatInput) {
        headerChatInput.value = message;
        sendHeaderMessage();
      }
    }

    function addMessage(content, sender) {
      const messageDiv = document.createElement('div');
      messageDiv.className = `message ${sender}`;
      
      const avatar = sender === 'user' ? 'üë§' : 'ü§ñ';
      const time = new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
      
      messageDiv.innerHTML = `
        <div class="message-avatar">${avatar}</div>
        <div class="message-content">
          ${content}
          <div class="message-time">${time}</div>
        </div>
      `;
      
      // Remove welcome message if it exists
      const welcomeMessage = chatContainer.querySelector('.welcome-message');
      if (welcomeMessage) {
        welcomeMessage.remove();
      }
      
      chatContainer.appendChild(messageDiv);
      chatContainer.scrollTop = chatContainer.scrollHeight;
      
      // Store in history
      chatHistory.push({ content, sender, timestamp: new Date().toISOString() });
    }

    function showTypingIndicator() {
      typingIndicator.style.display = 'flex';
    }

    function hideTypingIndicator() {
      typingIndicator.style.display = 'none';
    }

    // Top bar management
    let isExpanded = true; // Start expanded so chat is visible

    function toggleTopBar() {
      if (isExpanded) {
        collapseTopBar();
      } else {
        expandTopBar();
      }
    }

    function expandTopBar() {
      if (!isExpanded) {
        isExpanded = true;
        document.body.classList.remove('collapsed');
        document.body.classList.add('expanded');
        console.log('üìñ Expanded top bar - chat moved to bottom');
        
        if (window.electronAPI && window.electronAPI.expandTopBar) {
          window.electronAPI.expandTopBar();
        }
      }
    }

    function collapseTopBar() {
      if (isExpanded) {
        isExpanded = false;
        document.body.classList.remove('expanded');
        document.body.classList.add('collapsed');
        console.log('üì¶ Collapsed top bar - chat moved to header');
        
        if (window.electronAPI && window.electronAPI.collapseTopBar) {
          window.electronAPI.collapseTopBar();
        }
      }
    }

    // Manual positioning management
    let isManuallyPositioned = false;

    function handleManualPositioning(manual) {
      isManuallyPositioned = manual;
      if (manual) {
        document.body.classList.add('manually-positioned');
        console.log('üéØ Bar is now manually positioned');
      } else {
        document.body.classList.remove('manually-positioned');
        console.log('üîÑ Bar returned to auto-positioning');
      }
    }

    // Reset position to auto-center
    async function resetPosition() {
      if (window.electronAPI && window.electronAPI.resetPosition) {
        const result = await window.electronAPI.resetPosition();
        if (result.success) {
          handleManualPositioning(false);
          console.log('‚úÖ Position reset to auto-center');
        }
      }
    }

    // Initialize
    document.addEventListener('DOMContentLoaded', function() {
      console.log('üöÄ HeyJarvis Top Bar loaded');
      
      // Start in expanded mode so chat interface is visible
      document.body.classList.add('expanded');
      
      // Add double-click to reset position
      const positionIndicator = document.querySelector('.position-indicator');
      if (positionIndicator) {
        positionIndicator.addEventListener('dblclick', (e) => {
          e.stopPropagation();
          resetPosition();
        });
      }
      
      // Auto-initialize all services
      initializeServices();
      
      // Setup event listeners
      if (window.electronAPI) {
        // Setup top bar event listeners
        if (window.electronAPI.onTopBarExpanded) {
          window.electronAPI.onTopBarExpanded((expanded) => {
            if (expanded && !isExpanded) {
              document.body.classList.remove('collapsed');
              document.body.classList.add('expanded');
              isExpanded = true;
            } else if (!expanded && isExpanded) {
              document.body.classList.remove('expanded');
              document.body.classList.add('collapsed');
              isExpanded = false;
            }
          });
        }

        // Listen for manual positioning events
        if (window.electronAPI.onTopBarManuallyPositioned) {
          window.electronAPI.onTopBarManuallyPositioned((manual) => {
            handleManualPositioning(manual);
          });
        }

        // Setup Slack event listeners
        if (window.electronAPI.onSlackMention) {
          window.electronAPI.onSlackMention(onSlackMention);
          window.electronAPI.onSlackMessage(onSlackMessage);
          
          window.electronAPI.onSlackConnected(() => {
            console.log('üîó Slack connected');
            slackConnected = true;
            updateStatusIndicator('slack', 'online', 'Connected');
            updateActivitySummary();
            startSlackUpdates();
            loadSlackMessages();
          });
          
          window.electronAPI.onSlackDisconnected(() => {
            console.log('üîå Slack disconnected');
            slackConnected = false;
            updateStatusIndicator('slack', 'offline', 'Disconnected');
            updateActivitySummary();
            stopSlackUpdates();
          });
          
          window.electronAPI.onSlackError((error) => {
            console.error('‚ùå Slack error:', error);
            updateStatusIndicator('slack', 'offline', 'Error');
            updateActivitySummary();
        });
      }
    }

      // Services will auto-initialize
      console.log('üéØ HeyJarvis ready - services will auto-initialize');
    });

    // Handle window clicks to restore from minimized state
    document.addEventListener('click', function(e) {
      if (isMinimized && !e.target.closest('.control-btn')) {
        minimizeWindow();
      }
    });
    
    // Auto-initialize services after a short delay as fallback
    setTimeout(() => {
      if (!servicesInitialized) {
        console.log('üîÑ Fallback initialization triggered');
        initializeServices();
      }
    }, 2000);
    
    // ===== FACT CHECKING FUNCTIONALITY =====
    
    async function startFactCheck() {
      try {
        addMessage('assistant', 'üîç Scanning screen for text content...');
          showTypingIndicator();
        
        // Get text content from screen using multiple methods
        let textBlocks = await captureAndExtractTextBlocks();
        
        if (!textBlocks || textBlocks.length === 0) {
          addMessage('assistant', '‚ùå No readable text found on screen. Make sure there\'s text content visible and try again.');
          return;
        }
        
        addMessage('assistant', `üìù Found ${textBlocks.length} text blocks. Analyzing for misinformation...`);
        
        // Analyze each text block with AI
        const suspiciousBlocks = [];
        
        for (const block of textBlocks) {
          const analysis = await analyzeTextBlock(block.text);
          if (analysis && analysis.length > 0) {
            // Add positioning info to analysis
            analysis.forEach((issue, index) => {
              suspiciousBlocks.push({
                id: `highlight-${Date.now()}-${index}`,
                text: issue.text,
                reason: issue.reason,
                confidence: issue.confidence || 0.7,
                x: block.x,
                y: block.y,
                width: block.width,
                height: block.height
              });
            });
          }
        }
        
        // Show results as screen highlights
        if (suspiciousBlocks.length > 0) {
          addMessage('assistant', `üö® Found ${suspiciousBlocks.length} potentially suspicious claims. Red highlights are now showing on your screen - click them for details!`);
          await window.electronAPI.highlights.show(suspiciousBlocks);
        } else {
          addMessage('assistant', '‚úÖ No obvious misinformation detected in the scanned content.');
        }
        
        } catch (error) {
        console.error('Fact check error:', error);
        addMessage('assistant', '‚ùå Fact check failed. Please try again.');
      } finally {
          hideTypingIndicator();
      }
    }
    
    async function captureAndExtractTextBlocks() {
      try {
        if (!window.electronAPI?.factCheck) {
          console.log('Fact check API not available, using clipboard fallback');
          return null;
        }
        
        // Capture screen
        const capture = await window.electronAPI.factCheck.captureScreen();
        
        if (!capture.success) {
          console.error('Screen capture failed:', capture.error);
          return null;
        }
        
        // Extract text blocks with positioning
        const textResult = await window.electronAPI.factCheck.extractText(capture.image);
        
        if (!textResult.success) {
          console.error('Text extraction failed:', textResult.error);
          return null;
        }
        
        return textResult.textBlocks;
        
      } catch (error) {
        console.error('Screen capture and OCR failed:', error);
        return null;
      }
    }
    
    function createMockTextBlocks(text) {
      // Create mock positioned text blocks for clipboard content
      // Try to position them more realistically based on typical content areas
      const blocks = [];
      
      // Split into sentences and paragraphs
      const sentences = text.split(/[.!?]+/).filter(s => s.trim().length > 10);
      
      // Get screen dimensions for better positioning
      const screenWidth = window.screen.width;
      const screenHeight = window.screen.height;
      
      // Common content area (center 70% of screen, avoiding edges)
      const contentStartX = Math.floor(screenWidth * 0.15);
      const contentEndX = Math.floor(screenWidth * 0.85);
      const contentStartY = Math.floor(screenHeight * 0.15);
      const contentEndY = Math.floor(screenHeight * 0.85);
      
      sentences.forEach((sentence, index) => {
        const trimmed = sentence.trim();
        if (trimmed.length > 10) {
          // Distribute blocks across typical content areas
          const row = Math.floor(index / 2);
          const col = index % 2;
          
          blocks.push({
            text: trimmed,
            x: contentStartX + (col * Math.floor((contentEndX - contentStartX) / 2)),
            y: contentStartY + (row * 60), // 60px between rows
            width: Math.min(trimmed.length * 7, Math.floor((contentEndX - contentStartX) / 2) - 20),
            height: 40 // Taller for better visibility
          });
        }
      });
      
      // If no sentences, create blocks from paragraphs
      if (blocks.length === 0) {
        const paragraphs = text.split(/\n\s*\n/).filter(p => p.trim().length > 20);
        paragraphs.forEach((paragraph, index) => {
          blocks.push({
            text: paragraph.trim(),
            x: contentStartX,
            y: contentStartY + (index * 100),
            width: Math.min(paragraph.length * 6, contentEndX - contentStartX - 40),
            height: 60
          });
        });
      }
      
      return blocks;
    }
    
    async function analyzeTextBlock(text) {
      // Analyze individual text block (same as before but for single block)
      try {
        const prompt = `Analyze this specific text for potential misinformation, exaggerations, or suspicious claims:
        
        Text: "${text}"
        
        If you find issues, respond with a JSON array containing objects with:
        - "text": the exact suspicious part (keep under 50 chars)
        - "reason": brief explanation why it's suspicious
        - "confidence": number from 0-1 (how confident you are it's problematic)
        
        If no issues found, return empty array []. Only return valid JSON.`;
        
        const response = await window.electronAPI.ai.simpleAnalyze(prompt);
        
        // Try to parse as JSON
        try {
          const parsed = JSON.parse(response);
          return Array.isArray(parsed) ? parsed : [];
        } catch (parseError) {
          // Fallback: check if response indicates issues
          if (response.toLowerCase().includes('suspicious') || 
              response.toLowerCase().includes('problematic') ||
              response.toLowerCase().includes('unverifiable')) {
            return [{
              text: text.substring(0, 50) + (text.length > 50 ? '...' : ''),
              reason: response,
              confidence: 0.6
            }];
          }
          return [];
        }
        
      } catch (error) {
        console.error('Text block analysis failed:', error);
        return [];
      }
    }
    
    async function getClipboardContent() {
      try {
        return await navigator.clipboard.readText();
      } catch (error) {
        console.error('Clipboard access failed:', error);
        return null;
      }
    }
    
    async function analyzeWithAI(text) {
      try {
        const prompt = `Analyze this text for potential misinformation, exaggerations, or suspicious claims. Look for:
        - Unverifiable statistics or numbers
        - Exaggerated or superlative claims ("best ever", "never before seen")
        - Missing sources for bold statements
        - Logical inconsistencies
        - Claims that seem too good to be true
        
        For each suspicious part you find, respond with a JSON array containing objects with:
        - "text": the exact suspicious text (keep it short, under 100 chars)
        - "reason": brief explanation why it's suspicious
        - "confidence": number from 0-1 (how confident you are it's problematic)
        
        Text to analyze: "${text.substring(0, 2000)}"${text.length > 2000 ? '...' : ''}
        
        If no issues found, return empty array []. Only return valid JSON.`;
        
        if (!window.electronAPI?.ai) {
          throw new Error('AI analysis not available');
        }
        
        const response = await window.electronAPI.ai.simpleAnalyze(prompt);
        
        // Try to parse as JSON, fallback to simple analysis
        try {
          const parsed = JSON.parse(response);
          return Array.isArray(parsed) ? parsed : [];
        } catch (parseError) {
          // Fallback: create simple analysis from text response
          if (response.toLowerCase().includes('suspicious') || 
              response.toLowerCase().includes('problematic') ||
              response.toLowerCase().includes('unverifiable')) {
            return [{
              text: text.substring(0, 100) + (text.length > 100 ? '...' : ''),
              reason: response,
              confidence: 0.6
            }];
          }
          return [];
        }
        
      } catch (error) {
        console.error('AI analysis failed:', error);
        return [];
      }
    }
    
    function displayFactCheckResults(analysis, originalText) {
      if (!analysis || analysis.length === 0) {
        addMessage('assistant', '‚úÖ No obvious misinformation detected in the analyzed text.');
        return;
      }
      
      addMessage('assistant', `‚ö†Ô∏è Found ${analysis.length} potentially suspicious claim${analysis.length > 1 ? 's' : ''}:`);
      
      analysis.forEach((item, index) => {
        const confidence = Math.round((item.confidence || 0.5) * 100);
        const color = confidence > 70 ? '#dc3545' : confidence > 40 ? '#ffc107' : '#28a745';
        
        const highlightHtml = `
          <div class="fact-check-item" style="
            background: rgba(255, 0, 0, 0.1); 
            border-left: 3px solid ${color}; 
            padding: 12px; 
            margin: 8px 0; 
            border-radius: 4px;
            cursor: pointer;
          " onclick="showDetailedAnalysis('${encodeURIComponent(item.reason)}', '${encodeURIComponent(item.text)}')">
            <strong>üö® Suspicious Claim #${index + 1}</strong><br>
            <em>"${item.text}"</em><br>
            <small style="color: ${color};">Risk Level: ${confidence}% ‚Ä¢ Click for details</small>
          </div>
        `;
        
        addMessage('assistant', highlightHtml);
      });
    }
    
    function showDetailedAnalysis(encodedReason, encodedText) {
      const reason = decodeURIComponent(encodedReason);
      const suspiciousText = decodeURIComponent(encodedText);
      
      const detailHtml = `
        <div style="background: rgba(0, 0, 0, 0.1); padding: 15px; border-radius: 8px; margin: 10px 0;">
          <strong>üîç Detailed Analysis:</strong><br><br>
          <strong>Suspicious Text:</strong><br>
          <em>"${suspiciousText}"</em><br><br>
          <strong>Why This Might Be Problematic:</strong><br>
          ${reason}
        </div>
      `;
      
      addMessage('assistant', detailHtml);
    }
    
    // OCR-based text detection function
    async function findHeyjarvisText() {
      try {
        addMessage('assistant', 'üîç <strong>Finding "HeyJarvis" text using OCR...</strong><br><br>This will:<br>‚Ä¢ üì∏ Capture your current screen<br>‚Ä¢ ü§ñ Run OCR (Optical Character Recognition)<br>‚Ä¢ üéØ Find all instances of "heyjarvis", "jarvis", or "hey"<br>‚Ä¢ üìç Highlight them at their exact positions<br><br>Please wait while I scan your screen...');
        showTypingIndicator();
        
        const result = await window.electronAPI.highlights.findHeyjarvis();
        
        if (result.success) {
          let methodDescription = '';
          switch (result.method) {
            case 'ocr':
              methodDescription = 'using real OCR text detection with coordinate scaling';
              break;
            case 'ocr-smart-positioning':
              methodDescription = 'using OCR detection with smart positioning (hybrid approach)';
              break;
            case 'text-flow-positioning':
              methodDescription = 'using text flow analysis for intelligent positioning';
              break;
            case 'manual-positioning':
              methodDescription = 'using manual positioning based on ChatGPT layout analysis';
              break;
            case 'known-locations':
              methodDescription = 'using known "jarvis" text locations (OCR fallback)';
              break;
            default:
              methodDescription = 'using text detection';
          }
          
          addMessage('assistant', `‚úÖ <strong>Success!</strong> Found ${result.found} instances of "jarvis" text ${methodDescription}.<br><br>üéØ <strong>Red highlights should now be visible</strong> on your screen with <strong>improved coordinate mapping</strong>!<br><br>‚Ä¢ Click any highlight for details<br>‚Ä¢ Coordinates are now scaled to match your screen<br>‚Ä¢ Method used: ${result.method}<br>‚Ä¢ Check console for detailed coordinate mapping logs<br><br>The highlights should now appear much closer to the actual text! üöÄ`);
        } else {
          addMessage('assistant', `‚ö†Ô∏è <strong>Text detection had issues:</strong><br><br>${result.error}<br><br>You should still see a fallback highlight. This could mean:<br>‚Ä¢ OCR processing failed<br>‚Ä¢ No "jarvis" text is visible on screen<br>‚Ä¢ Screen capture had issues<br><br>The system will keep trying to improve detection. Check the console for detailed logs.`);
        }
        
      } catch (error) {
        console.error('OCR text detection error:', error);
        addMessage('assistant', '‚ùå OCR text detection failed. This could be due to:<br>‚Ä¢ Screen capture permissions<br>‚Ä¢ OCR processing error<br>‚Ä¢ System compatibility issue<br><br>Check the console for detailed error information.');
      } finally {
        hideTypingIndicator();
      }
    }

    // Calibration function to help fine-tune positioning
    async function calibrateHighlights() {
      try {
        addMessage('assistant', 'üéØ <strong>Starting Coordinate Calibration...</strong><br><br>This will show:<br>‚Ä¢ üü¢ <strong>Lime green grid</strong> - 3x3 calibration points with exact coordinates<br>‚Ä¢ üîµ <strong>Cyan corner markers</strong> - Screen corner reference points<br>‚Ä¢ üìç Each shows its exact (x, y) position<br><br>Use this to verify highlight positioning accuracy!');
        showTypingIndicator();
        
        const result = await window.electronAPI.highlights.calibrate();
        
        if (result.success) {
          addMessage('assistant', `‚úÖ <strong>Calibration Grid Active!</strong><br><br>üéØ You should now see <strong>${result.found} calibration points</strong> on your screen:<br><br>‚Ä¢ <strong>Lime green boxes</strong> = Grid points with coordinates<br>‚Ä¢ <strong>Cyan boxes</strong> = Corner markers<br>‚Ä¢ Screen dimensions: ${result.screenDimensions.width}x${result.screenDimensions.height}<br><br>If these appear in the right places, the coordinate system is working correctly! Use this to compare with OCR positioning.`);
        } else {
          addMessage('assistant', `‚ùå <strong>Calibration failed:</strong> ${result.error}<br><br>Check the console for details.`);
        }
        
      } catch (error) {
        console.error('Calibration error:', error);
        addMessage('assistant', '‚ùå Calibration system failed. Check console for details.');
      } finally {
        hideTypingIndicator();
      }
    }

    // Simple test highlights function - bypasses OCR completely
    async function testSimpleHighlights() {
      try {
        addMessage('assistant', 'üî¥ <strong>Testing Simple Highlights...</strong><br><br>This bypasses all OCR and creates highlights at hardcoded positions to test the overlay system directly.');
        showTypingIndicator();
        
        // Create simple test highlights at known positions
        const simpleHighlights = [
          {
            id: 'simple-test-1',
            text: 'TEST 1',
            reason: 'Simple test highlight at (500, 200)',
            confidence: 1.0,
            x: 500,
            y: 200,
            width: 100,
            height: 30
          },
          {
            id: 'simple-test-2', 
            text: 'TEST 2',
            reason: 'Simple test highlight at (600, 300)',
            confidence: 1.0,
            x: 600,
            y: 300,
            width: 100,
            height: 30
          },
          {
            id: 'simple-test-3',
            text: 'TEST 3',
            reason: 'Simple test highlight at (700, 400)',
            confidence: 1.0,
            x: 700,
            y: 400,
            width: 100,
            height: 30
          }
        ];
        
        // Send directly to highlight system
        await window.electronAPI.highlights.show(simpleHighlights);
        
        addMessage('assistant', `‚úÖ <strong>Simple Test Complete!</strong><br><br>Created 3 test highlights at:<br>‚Ä¢ (500, 200) - TEST 1<br>‚Ä¢ (600, 300) - TEST 2<br>‚Ä¢ (700, 400) - TEST 3<br><br>If these appear at the correct positions, the overlay system is working and the issue is with coordinate calculation in the OCR system.`);
        
      } catch (error) {
        console.error('Simple test error:', error);
        addMessage('assistant', '‚ùå Simple test failed. Check console for details.');
      } finally {
        hideTypingIndicator();
      }
    }

    // Test highlights function
    async function testHighlights() {
      try {
        addMessage('assistant', 'üß™ Testing highlight overlay system...<br><br>This will:<br>‚Ä¢ Try to detect "heyjarvis" text using accessibility APIs<br>‚Ä¢ Show debug highlights at key screen positions<br>‚Ä¢ Display coordinates to help debug positioning<br><br>Look for colorful boxes with coordinates appearing on your screen!');
        showTypingIndicator();
        
        const result = await window.electronAPI.highlights.test();
        
        if (result.success) {
          addMessage('assistant', `üéØ Test complete! Created ${result.found} highlights.<br><br><strong>What to look for:</strong><br>‚Ä¢ Colored boxes at corners and center of screen<br>‚Ä¢ Each box shows coordinates like "(x, y)"<br>‚Ä¢ Different colors indicate different test areas<br>‚Ä¢ If you see these, the overlay system is working!<br><br>If highlights appear in wrong places, we can adjust the positioning logic.`);
        } else {
          addMessage('assistant', `‚ö†Ô∏è Test completed with issues: ${result.error}<br><br>But you should still see fallback debug highlights on your screen. Check the console for detailed logs.`);
        }
        
      } catch (error) {
        console.error('Test highlights error:', error);
        addMessage('assistant', '‚ùå Test highlights failed. Check console for details.');
      } finally {
        hideTypingIndicator();
      }
    }
    
    // Listen for explanation requests from highlights
    if (window.electronAPI?.onShowExplanation) {
      window.electronAPI.onShowExplanation((data) => {
        const explanationHtml = `
          <div style="background: rgba(255, 59, 48, 0.1); padding: 15px; border-radius: 8px; margin: 10px 0; border-left: 3px solid #ff3b30;">
            <strong>üö® Suspicious Content Detected</strong><br><br>
            <strong>Highlighted Text:</strong><br>
            <em>"${data.text}"</em><br><br>
            <strong>Why This Might Be Problematic:</strong><br>
            ${data.reason}<br><br>
            <small style="color: #ff3b30;">Confidence: ${Math.round(data.confidence * 100)}%</small>
          </div>
        `;
        
        addMessage('assistant', explanationHtml);
      });
    }
    
  </script>
</body>
</html>